-- NOTE: This script was generated by AI.

package.path = "src/?.lua;src/?/init.lua;" .. package.path

local lfs = require("lfs")
local List = require("mods.List")
local str = require("mods.str")

local fmt = string.format

local TYPES_DIR = "types"
local OUT_DIR = "docs/modules"
local INDEX_OUT = OUT_DIR .. "/index.md"

local function push_all(list, ...)
  for i = 1, select("#", ...) do
    list:append(select(i, ...))
  end
end

local function read_file(path)
  local f = assert(io.open(path, "r"))
  local data = f:read("*a")
  f:close()
  return data
end

local function write_file(path, data)
  local f = assert(io.open(path, "w"))
  f:write(data)
  f:close()
end

local function slugify_anchor(name, params)
  local base = name .. "(" .. params .. ")"
  base = base:gsub("[()]", "")
  base = base:gsub("%s* ,%s*", "-")
  base = base:gsub(",%s*", "-")
  base = base:gsub("%s+", "")
  return "fn-" .. str.lower(base)
end

local function parse_block(block_lines)
  local desc_lines = {}
  local anno_lines = {}
  local example_lines = {}
  local alias_lines = {}
  local in_example = false
  local in_aliases = false

  for _, line in ipairs(block_lines) do
    if str.startswith(line, "@") then
      in_aliases = false
      table.insert(anno_lines, line)
    elseif line:match("^%*%*Example:%*%*") then
      in_example = true
      in_aliases = false
    elseif line:match("^%*%*Aliases:%*%*") then
      local first = line:gsub("^%*%*Aliases:%*%*%s*", "")
      if first ~= "" then
        table.insert(alias_lines, first)
      end
      in_example = false
      in_aliases = true
    elseif in_aliases then
      if line == "" then
        if #alias_lines > 0 and alias_lines[#alias_lines] ~= "" then
          table.insert(alias_lines, "")
        end
      else
        table.insert(alias_lines, line)
      end
    elseif in_example then
      table.insert(example_lines, line)
    elseif line == "" then
      if #desc_lines > 0 and desc_lines[#desc_lines] ~= "" then
        table.insert(desc_lines, "")
      end
    else
      table.insert(desc_lines, line)
    end
  end

  local desc = str.strip(table.concat(desc_lines, "\n"))
  local example = nil
  if #example_lines > 0 then
    example = str.strip(table.concat(example_lines, "\n"))
  end
  local aliases = nil
  if #alias_lines > 0 then
    aliases = str.strip(table.concat(alias_lines, "\n"))
  end

  return {
    desc = desc,
    annotations = anno_lines,
    example = example,
    aliases = aliases,
  }
end

local function display_name(meta)
  return meta and meta:gsub("^mods%.", "") or nil
end

local function parse_types_file(path)
  local lines = {}
  for line in read_file(path):gmatch("[^\n]*\n?") do
    if line == "" then
      break
    end
    local cleaned = line:gsub("\n$", "")
    lines[#lines + 1] = cleaned
  end

  local meta
  local module_desc_lines = {}
  local block = nil
  local funcs = {}
  local seen_class = false
  local current_section = nil

  local function flush_block()
    block = nil
  end

  for _, raw in ipairs(lines) do
    local line = raw
    if str.startswith(line, "---") then
      local text = line:gsub("^%-%-%-%s?", "")
      if text:match("^@meta%s+") then
        meta = text:gsub("^@meta%s+", "")
      elseif text:match("^@class%s+") then
        flush_block()
        seen_class = true
      else
        local section = text:match("^##%s+(.+)$")
        if not section then
          local tail = line:match("%-+$")
          if tail and #tail >= 3 then
            section = text:match("^%-*%s*(.-)%s*%-+$")
          end
        end
        if section and section ~= "" then
          current_section = str.strip(section)
        else
        block = block or {}
        table.insert(block, text)
        if meta and not seen_class and not text:match("^@") and not text:match("^|") then
          if text == "" then
            if #module_desc_lines > 0 and module_desc_lines[#module_desc_lines] ~= "" then
              module_desc_lines[#module_desc_lines + 1] = ""
            end
          else
            module_desc_lines[#module_desc_lines + 1] = text
          end
        end
        end
      end
    else
      local fn_full, params = line:match("^function%s+([%w%._:]+)%s*%(([^)]*)%)")
      if not fn_full then
        fn_full, params = line:match("^([%w%._]+)%s*=%s*function%s*%(([^)]*)%)")
      end
      if fn_full then
        local name = fn_full:match("[^%.:]+$")
        local doc = parse_block(block or {})
        funcs[#funcs + 1] = {
          name = name,
          params = str.strip(params),
          section = current_section,
          doc = doc,
          annotations = doc.annotations,
        }

        block = nil
      else
        flush_block()
      end
    end
  end

  local module_desc = str.strip(table.concat(module_desc_lines, "\n"))
  return {
    meta = meta,
    module_desc = module_desc or "",
    functions = funcs,
  }
end

local function module_short_name(meta)
  local name = display_name(meta)
  return name and name:lower() or nil
end

local function render_module(doc)
  local short = module_short_name(doc.meta) or "module"
  local title = display_name(doc.meta) or short
  local out = List()
  local anchor_counts = {}

  local function make_validate_default_aliases(name)
    local lower = str.lower(name)
    local aliases, seen = {}, {}
    local function add(a)
      if not seen[a] then
        seen[a] = true
        aliases[#aliases + 1] = "`" .. a .. "`"
      end
    end
    add(name)
    add(lower)
    add("is." .. name)
    add("is." .. lower)
    add("is_" .. name)
    add("is_" .. lower)
    return table.concat(aliases, ", ")
  end

  if doc.meta and doc.meta ~= "" then
    local type_name = display_name(doc.meta)
    push_all(out, "---", "editLinkTarget: types/" .. type_name .. ".lua", "---", "")
  end

  for _, fn in ipairs(doc.functions) do
    local base = slugify_anchor(fn.name, fn.params)
    local n = (anchor_counts[base] or 0) + 1
    anchor_counts[base] = n
    fn.occurrence = n
    if n == 1 then
      fn.anchor = base
    else
      fn.anchor = base .. "-" .. tostring(n)
    end
  end

  push_all(out, "# `" .. title .. "`", "", doc.module_desc, "")

  if #doc.functions > 0 then
    push_all(out, "## Quick Reference", "")
    local current_section = nil
    local has_sections = false
    for _, fn in ipairs(doc.functions) do
      if fn.section then
        has_sections = true
        break
      end
    end
    if not has_sections then
      push_all(out, "| Function | Description |", "| --- | --- |")
    end
    for _, fn in ipairs(doc.functions) do
      if has_sections then
        if fn.section ~= current_section then
          current_section = fn.section or "Other"
          push_all(out, "**" .. current_section .. "**", "", "| Function | Description |", "| --- | --- |")
        end
      end
      local desc = fn.doc.desc:gsub("\n.*", "")
      push_all(out, fmt("| [`%s(%s)`](#%s) | %s |", fn.name, fn.params, fn.anchor, desc))
    end
    push_all(out, "", "## Functions", "")
    local current_section = nil
    for _, fn in ipairs(doc.functions) do
      if fn.section and fn.section ~= current_section then
        current_section = fn.section
        push_all(out, "### " .. current_section, "")
      end
      push_all(out, fmt("#### `%s(%s)` {#%s}", fn.name, fn.params, fn.anchor), "")
      local function format_aliases_md(raw)
        if not raw or raw == "" then
          return nil
        end
        local compact = raw:gsub("%s*\n%s*", " ")
        local bullets = {}
        for chunk in compact:gmatch("[^,]+") do
          local alias = str.strip(chunk)
          alias = alias:gsub("^`", ""):gsub("`$", "")
          if alias ~= "" then
            bullets[#bullets + 1] = "- `" .. alias .. "`"
          end
        end
        if #bullets > 0 then
          return table.concat(bullets, "\n")
        end
        return raw
      end

      local desc = fn.doc.desc or ""
      local aliases = fn.doc.aliases
      if (not aliases or aliases == "") and short == "validate" then
        if not desc:find("%*%*not%*%*") then
          aliases = make_validate_default_aliases(fn.name)
        end
      end
      if (not aliases or aliases == "") and desc ~= "" then
        local lines = {}
        for line in (desc .. "\n"):gmatch("(.-)\n") do
          lines[#lines + 1] = line
        end
        local i = #lines
        while i > 0 and lines[i] == "" do
          i = i - 1
        end
        if i > 0 and lines[i]:match("^`.+`$") and lines[i]:find("`, `", 1, true) then
          aliases = lines[i]
          lines[i] = nil
          while #lines > 0 and lines[#lines] == "" do
            lines[#lines] = nil
          end
          desc = str.strip(table.concat(lines, "\n"))
        end
      end

      if desc ~= "" then
        push_all(out, desc, "")
      end
      push_all(out, ":::tabs")
      if fn.doc.example and fn.doc.example ~= "" then
        push_all(out, "== Example", "", fn.doc.example, "")
      end
      if aliases and aliases ~= "" then
        push_all(out, "== Aliases", "", format_aliases_md(aliases), "")
      end
      push_all(out, "== Signature", "", "```lua")
      for _, anno in ipairs(fn.annotations or {}) do
        local cleaned = anno:gsub("^@", "")
        push_all(out, "---@" .. cleaned)
      end
      local signature = fmt("function %s(%s) end", fn.name, fn.params)
      push_all(out, signature, "```", "", ":::", "")
    end
  end

  return out:join("\n")
end

local function render_index(docs)
  local out = List()

  push_all(out, "| Module | Description |", "| --- | --- |")
  for _, doc in ipairs(docs) do
    local short = module_short_name(doc.meta)
    if short then
      local name = display_name(doc.meta) or short
      local flat = (doc.module_desc or ""):gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")
      local desc = flat:match("^(.-%.)%s") or flat:match("^(.-%.)$") or flat
      local link = fmt("/modules/%s", short)
      push_all(out, fmt("| [`%s`](%s) | %s |", name, link, desc))
    end
  end
  push_all(out, "")

  return table.concat(out, "\n")
end

local function list_lua_files(dir)
  local files = List()
  for file in lfs.dir(dir) do
    if file ~= "." and file ~= ".." and str.endswith(file, ".lua") then
      files:append(dir .. "/" .. file)
    end
  end
  return files:sort()
end

local function main()
  local files = list_lua_files(TYPES_DIR)
  local docs = {}
  for _, path in ipairs(files) do
    local doc = parse_types_file(path)
    local short = module_short_name(doc.meta)
    if short and short ~= "mods" then
      local out_path = OUT_DIR .. "/" .. short .. ".md"
      local content = render_module(doc)
      write_file(out_path, content)
      print("wrote", out_path)
      docs[#docs + 1] = doc
    end
  end

  local index = render_index(docs)
  write_file(INDEX_OUT, index)
  print("wrote", INDEX_OUT)
end

main()
