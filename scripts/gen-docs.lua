-- NOTE: This script was generated by AI.

package.path = "src/?.lua;src/?/init.lua;" .. package.path

local lfs = require("lfs")
local List = require("mods.List")
local str = require("mods.str")

local fmt = string.format

local TYPES_DIR = "types"
local OUT_DIR = "docs/modules"
local INDEX_OUT = OUT_DIR .. "/index.md"

local function push_all(list, ...)
  for i = 1, select("#", ...) do
    list:append(select(i, ...))
  end
end

local function read_file(path)
  local f = assert(io.open(path, "r"))
  local data = f:read("*a")
  f:close()
  return data
end

local function write_file(path, data)
  local f = assert(io.open(path, "w"))
  f:write(data)
  f:close()
end

local function slugify_anchor(name, params)
  local base = name .. "(" .. params .. ")"
  base = base:gsub("[()]", "")
  base = base:gsub("%s* ,%s*", "-")
  base = base:gsub(",%s*", "-")
  base = base:gsub("%s+", "")
  return "fn-" .. str.lower(base)
end

local function parse_block(block_lines)
  local desc_lines = {}
  local anno_lines = {}
  local example_lines = {}
  local in_example = false

  for _, line in ipairs(block_lines) do
    if str.startswith(line, "@") then
      table.insert(anno_lines, line)
    elseif line:match("^%*%*Example:%*%*") then
      in_example = true
    elseif in_example then
      table.insert(example_lines, line)
    elseif line == "" then
      if #desc_lines > 0 and desc_lines[#desc_lines] ~= "" then
        table.insert(desc_lines, "")
      end
    else
      table.insert(desc_lines, line)
    end
  end

  local desc = str.strip(table.concat(desc_lines, "\n"))
  local example = nil
  if #example_lines > 0 then
    example = str.strip(table.concat(example_lines, "\n"))
  end

  return {
    desc = desc,
    annotations = anno_lines,
    example = example,
  }
end

local function display_name(meta)
  return meta and meta:gsub("^mods%.", "") or nil
end

local function parse_types_file(path)
  local lines = {}
  for line in read_file(path):gmatch("[^\n]*\n?") do
    if line == "" then
      break
    end
    local cleaned = line:gsub("\n$", "")
    lines[#lines + 1] = cleaned
  end

  local meta
  local module_desc_lines = {}
  local block = nil
  local funcs = {}
  local seen_class = false
  local current_section = nil

  local function flush_block()
    block = nil
  end

  for _, raw in ipairs(lines) do
    local line = raw
    if str.startswith(line, "---") then
      local text = line:gsub("^%-%-%-%s?", "")
      if text:match("^@meta%s+") then
        meta = text:gsub("^@meta%s+", "")
      elseif text:match("^@class%s+") then
        flush_block()
        seen_class = true
      else
        local section = text:match("^##%s+(.+)$")
        if section then
          current_section = section
        else
        block = block or {}
        table.insert(block, text)
        if meta and not seen_class and not text:match("^@") and not text:match("^|") then
          if text == "" then
            if #module_desc_lines > 0 and module_desc_lines[#module_desc_lines] ~= "" then
              module_desc_lines[#module_desc_lines + 1] = ""
            end
          else
            module_desc_lines[#module_desc_lines + 1] = text
          end
        end
        end
      end
    else
      local fn_full, params = line:match("^function%s+([%w%._:]+)%s*%(([^)]*)%)")
      if not fn_full then
        fn_full, params = line:match("^([%w%._]+)%s*=%s*function%s*%(([^)]*)%)")
      end
      if fn_full then
        local name = fn_full:match("[^%.:]+$")
        local doc = parse_block(block or {})
        funcs[#funcs + 1] = {
          name = name,
          params = str.strip(params),
          section = current_section,
          doc = doc,
          annotations = doc.annotations,
        }

        block = nil
      else
        flush_block()
      end
    end
  end

  local module_desc = str.strip(table.concat(module_desc_lines, "\n"))
  return {
    meta = meta,
    module_desc = module_desc or "",
    functions = funcs,
  }
end

local function module_short_name(meta)
  local name = display_name(meta)
  return name and name:lower() or nil
end

local function render_module(doc)
  local short = module_short_name(doc.meta) or "module"
  local title = display_name(doc.meta) or short
  local out = List()

  if doc.meta and doc.meta ~= "" then
    local type_name = display_name(doc.meta)
    push_all(out, "---", "editLinkTarget: types/" .. type_name .. ".lua", "---", "")
  end

  push_all(out, "# `" .. title .. "`", "", doc.module_desc, "")

  if #doc.functions > 0 then
    push_all(out, "## Quick Reference", "")
    local current_section = nil
    local has_sections = false
    for _, fn in ipairs(doc.functions) do
      if fn.section then
        has_sections = true
        break
      end
    end
    if not has_sections then
      push_all(out, "| Function | Description |", "| --- | --- |")
    end
    for _, fn in ipairs(doc.functions) do
      if has_sections then
        if fn.section ~= current_section then
          current_section = fn.section or "Other"
          push_all(out, "### " .. current_section, "", "| Function | Description |", "| --- | --- |")
        end
      end
      local desc = fn.doc.desc:gsub("\n.*", "")
      local anchor = slugify_anchor(fn.name, fn.params)
      push_all(out, fmt("| [`%s(%s)`](#%s) | %s |", fn.name, fn.params, anchor, desc))
    end
    push_all(out, "", "## Functions", "")
    local current_section = nil
    for _, fn in ipairs(doc.functions) do
      if fn.section and fn.section ~= current_section then
        current_section = fn.section
        push_all(out, "### " .. current_section, "")
      end
      local anchor = slugify_anchor(fn.name, fn.params)
      push_all(out, fmt("#### `%s(%s)` {#%s}", fn.name, fn.params, anchor), "")
      if fn.doc.desc ~= "" then
        push_all(out, fn.doc.desc, "")
      end
      push_all(out, ":::tabs")
      if fn.doc.example and fn.doc.example ~= "" then
        push_all(out, "== Example", "", fn.doc.example, "")
      end
      push_all(out, "== Signature", "", "```lua")
      for _, anno in ipairs(fn.annotations or {}) do
        local cleaned = anno:gsub("^@", "")
        push_all(out, "---@" .. cleaned)
      end
      local signature = fmt("function %s(%s) end", fn.name, fn.params)
      push_all(out, signature, "```", "", ":::", "")
    end
  end

  return out:join("\n")
end

local function render_index(docs)
  local out = List()

  push_all(out, "| Module | Description |", "| --- | --- |")
  for _, doc in ipairs(docs) do
    local short = module_short_name(doc.meta)
    if short then
      local name = display_name(doc.meta) or short
      local flat = (doc.module_desc or ""):gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")
      local desc = flat:match("^(.-%.)%s") or flat:match("^(.-%.)$") or flat
      local link = fmt("/modules/%s", short)
      push_all(out, fmt("| [`%s`](%s) | %s |", name, link, desc))
    end
  end
  push_all(out, "")

  return table.concat(out, "\n")
end

local function list_lua_files(dir)
  local files = List()
  for file in lfs.dir(dir) do
    if file ~= "." and file ~= ".." and str.endswith(file, ".lua") then
      files:append(dir .. "/" .. file)
    end
  end
  return files:sort()
end

local function main()
  local files = list_lua_files(TYPES_DIR)
  local docs = {}
  for _, path in ipairs(files) do
    local doc = parse_types_file(path)
    local short = module_short_name(doc.meta)
    if short and short ~= "mods" then
      local out_path = OUT_DIR .. "/" .. short .. ".md"
      local content = render_module(doc)
      write_file(out_path, content)
      print("wrote", out_path)
      docs[#docs + 1] = doc
    end
  end

  local index = render_index(docs)
  write_file(INDEX_OUT, index)
  print("wrote", INDEX_OUT)
end

main()
